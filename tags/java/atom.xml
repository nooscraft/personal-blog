<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Noos - Where Thought, Code, and Craft Converge - java</title>
    <subtitle>Personal blog about programming, technology, and engineering insights. Topics include Rust, DevOps, Linux, and software craftsmanship.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://noos.blog/tags/java/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://noos.blog"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-11-02T00:00:00+00:00</updated>
    <id>https://noos.blog/tags/java/atom.xml</id>
    <entry xml:lang="en">
        <title>Java vs Rust: A ROUGE-L Performance Comparison</title>
        <published>2025-11-02T00:00:00+00:00</published>
        <updated>2025-11-02T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://noos.blog/posts/java-vs-rust-rouge-l-performance/"/>
        <id>https://noos.blog/posts/java-vs-rust-rouge-l-performance/</id>
        
        <content type="html" xml:base="https://noos.blog/posts/java-vs-rust-rouge-l-performance/">&lt;h3 id=&quot;the-experiment&quot;&gt;The Experiment&lt;&#x2F;h3&gt;
&lt;p&gt;I was curious about the performance differences between Java and Rust for a specific workload. So I built identical ROUGE-L implementations in both languages and ran some benchmarks. The code was AI-generated, the algorithm was the same, and the results were mathematically equivalent. But the performance? That&#x27;s where it gets interesting.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-is-rouge-l&quot;&gt;What is ROUGE-L?&lt;&#x2F;h3&gt;
&lt;p&gt;ROUGE-L (Recall-Oriented Understudy for Gisting Evaluation - Longest Common Subsequence) is a metric used to evaluate text summarization quality. It&#x27;s part of the &lt;a href=&quot;https:&#x2F;&#x2F;aclanthology.org&#x2F;W04-1013&#x2F;&quot;&gt;ROUGE evaluation suite&lt;&#x2F;a&gt; developed by Chin-Yew Lin in 2004, which has become a standard in natural language processing for assessing how well generated summaries match reference summaries.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How it works:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;ROUGE-L measures similarity based on the Longest Common Subsequence (LCS) between sequences of words. It calculates three metrics:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Precision&lt;&#x2F;strong&gt;: LCS &#x2F; (number of words in candidate summary)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Recall&lt;&#x2F;strong&gt;: LCS &#x2F; (number of words in reference summary)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;F-Measure&lt;&#x2F;strong&gt;: 2 × (Precision × Recall) &#x2F; (Precision + Recall)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The algorithm uses dynamic programming with O(m × n) time complexity, where m and n are the lengths of the two sequences. It&#x27;s a straightforward implementation, which makes it a good candidate for comparing language performance.&lt;&#x2F;p&gt;
&lt;p&gt;ROUGE-L is particularly useful because it doesn&#x27;t require exact word matches—it finds the longest sequence of words that appear in the same order in both texts, making it more flexible than n-gram overlap methods like ROUGE-1 or ROUGE-2.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-setup&quot;&gt;The Setup&lt;&#x2F;h3&gt;
&lt;p&gt;Both implementations:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Use the same dynamic programming algorithm for LCS calculation&lt;&#x2F;li&gt;
&lt;li&gt;Tokenize text the same way (lowercase, whitespace-based splitting)&lt;&#x2F;li&gt;
&lt;li&gt;Handle the same 16 test examples across 6 complexity levels&lt;&#x2F;li&gt;
&lt;li&gt;Produce identical mathematical results&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The only difference is the language they&#x27;re written in.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Test scenarios include:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Basic text comparisons&lt;&#x2F;li&gt;
&lt;li&gt;Structured data (JSON, HTML)&lt;&#x2F;li&gt;
&lt;li&gt;Mixed content with embedded structures&lt;&#x2F;li&gt;
&lt;li&gt;Real-world technical documentation&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;You can find the full comparison project on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nooscraft&#x2F;rouge-l-comparison&quot;&gt;GitHub&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-results&quot;&gt;The Results&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Accuracy:&lt;&#x2F;strong&gt; Both implementations produced &lt;strong&gt;100% identical results&lt;&#x2F;strong&gt; across all 16 test cases. Every F-Measure, Precision, and Recall value matched perfectly. This confirms the algorithms are mathematically equivalent.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Performance:&lt;&#x2F;strong&gt; That&#x27;s where things get interesting.&lt;&#x2F;p&gt;
&lt;p&gt;After multiple benchmark runs with 10 iterations each:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Java:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Average: 52-62ms per run&lt;&#x2F;li&gt;
&lt;li&gt;Median: 51-61ms&lt;&#x2F;li&gt;
&lt;li&gt;Standard deviation: 1.5-13ms (relatively consistent)&lt;&#x2F;li&gt;
&lt;li&gt;Includes JVM startup time in every run&lt;&#x2F;li&gt;
&lt;li&gt;Performance stabilizes quickly after first iteration&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Rust:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Average: 21-40ms (heavily skewed by first cold start)&lt;&#x2F;li&gt;
&lt;li&gt;Median: 2.5-4ms (after warmup)&lt;&#x2F;li&gt;
&lt;li&gt;First iteration: 190-360ms (cold start overhead including compilation)&lt;&#x2F;li&gt;
&lt;li&gt;Warm average: 2.4-4.4ms (excluding first run)&lt;&#x2F;li&gt;
&lt;li&gt;Standard deviation: 60-115ms (largely due to cold start variability)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;The speedup:&lt;&#x2F;strong&gt; After warmup, Rust was consistently &lt;strong&gt;12-25x faster&lt;&#x2F;strong&gt; than Java for this workload. For example, in one run: Java median 56.66ms vs Rust warm average 2.50ms = &lt;strong&gt;24.76x speedup&lt;&#x2F;strong&gt;. The median Rust time (2.5-3ms) versus Java&#x27;s median (52-56ms) tells the story.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-this-means&quot;&gt;What This Means&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;For Java:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;JVM startup adds significant overhead (~50-60ms)&lt;&#x2F;li&gt;
&lt;li&gt;Once running, performance is consistent&lt;&#x2F;li&gt;
&lt;li&gt;The runtime environment is predictable but has a fixed cost&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;For Rust:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Cold start includes compilation&#x2F;optimization overhead (~200-350ms)&lt;&#x2F;li&gt;
&lt;li&gt;Once warmed up, execution is extremely fast (~2.5-3ms)&lt;&#x2F;li&gt;
&lt;li&gt;Compiled binary runs without runtime interpretation overhead&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;The reality:&lt;&#x2F;strong&gt; In production, both would run with warmup periods. Java would maintain its ~55ms average. Rust would settle into its ~2.5-3ms sweet spot. The performance difference would still be substantial.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;observations&quot;&gt;Observations&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Tradeoffs:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Startup time:&lt;&#x2F;strong&gt; Java has consistent startup overhead. Rust has a larger initial cold start but negligible warm overhead.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Consistency:&lt;&#x2F;strong&gt; Java&#x27;s performance is more predictable from run to run. Rust&#x27;s cold start variability makes early measurements misleading.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Warm performance:&lt;&#x2F;strong&gt; Once both are warmed up, Rust&#x27;s compiled nature provides significant advantages for CPU-bound work.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ecosystem:&lt;&#x2F;strong&gt; Java has mature NLP libraries. Rust has growing ecosystem support. For this isolated algorithm, both worked well.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;The &quot;just for fun&quot; part:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This was an experiment. I wanted to see what would happen if you took the same algorithm, implemented it identically in two languages, and compared performance. The answer: same results, dramatically different performance characteristics.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;why-this-matters&quot;&gt;Why This Matters&lt;&#x2F;h3&gt;
&lt;p&gt;For production systems evaluating summarization quality:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Throughput matters:&lt;&#x2F;strong&gt; Processing thousands of summaries per second benefits from Rust&#x27;s speed&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Latency matters:&lt;&#x2F;strong&gt; If this runs in a request path, 2.5ms vs 55ms is significant&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Infrastructure matters:&lt;&#x2F;strong&gt; Java&#x27;s JVM ecosystem vs Rust&#x27;s compiled binary have different deployment considerations&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Neither is &quot;better&quot; in absolute terms. They have different tradeoffs. Understanding those tradeoffs is what matters.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;references&quot;&gt;References&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;aclanthology.org&#x2F;W04-1013&#x2F;&quot;&gt;Lin, C.-Y. (2004). ROUGE: A Package for Automatic Evaluation of Summaries&lt;&#x2F;a&gt; - The original paper introducing ROUGE metrics&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ROUGE_(metric)&quot;&gt;ROUGE Metrics Documentation&lt;&#x2F;a&gt; - Wikipedia overview of ROUGE evaluation metrics&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nooscraft&#x2F;rouge-l-comparison&quot;&gt;Comparison Project on GitHub&lt;&#x2F;a&gt; - Full source code and benchmarks&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;The code is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nooscraft&#x2F;rouge-l-comparison&quot;&gt;available on GitHub&lt;&#x2F;a&gt; if you want to run your own benchmarks. Same algorithm, same results, different performance characteristics. Sometimes the fun experiments teach you the most.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>JDK 9 and JShell</title>
        <published>2015-06-12T00:00:00+00:00</published>
        <updated>2015-06-12T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://noos.blog/posts/jdk-9-and-jshell/"/>
        <id>https://noos.blog/posts/jdk-9-and-jshell/</id>
        
        <content type="html" xml:base="https://noos.blog/posts/jdk-9-and-jshell/">&lt;h3 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h3&gt;
&lt;p&gt;I recently got to know about this official Java REPL (Read-Eval-Print-Loop) or JShell project. It is named as Kulla and you can visit &lt;a href=&quot;http:&#x2F;&#x2F;openjdk.java.net&#x2F;projects&#x2F;kulla&#x2F;&quot;&gt;here&lt;&#x2F;a&gt; to see the project&#x27;s home. This is pretty much same like the Python&#x27;s IDLE (If you have used it before) and a great way to exercise your code in real time. Also the good thing is that this project will be available as a part of JDK9 among with some other cool features.&lt;&#x2F;p&gt;
&lt;p&gt;Anyhow I managed to get it run on own and have tried few exercises too. Here, take a look&lt;&#x2F;p&gt;
&lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;https:&#x2F;&#x2F;asciinema.org&#x2F;a&#x2F;eddp51uxxwidh8vlpy91ufyj2.js&quot; id=&quot;asciicast-eddp51uxxwidh8vlpy91ufyj2&quot; async&gt;&lt;&#x2F;script&gt;
&lt;h3 id=&quot;how-do-i-get-it-to-run&quot;&gt;How do I get it to run&lt;&#x2F;h3&gt;
&lt;p&gt;I haven&#x27;t tried this on Windows, &lt;strong&gt;only on POSIX based systems (Linux)&lt;&#x2F;strong&gt;.  But I believe the precompiled jar will work on Windows. You can give it a go and see.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;easy-way&quot;&gt;Easy way&lt;&#x2F;h3&gt;
&lt;p&gt;If you want to try out REPL right away there&#x27;s this precompiled Jar that you can use . What you&#x27;ll need is&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Link for the Jar:Kulla.jar&lt;&#x2F;li&gt;
&lt;li&gt;Java 9 early access JDK&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Once these are in place you just need to set the JAVA_HOME to your &#x2F; path &#x2F; to &#x2F; JDK 9. Then execute the following -jar command:-&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;$ java -jar kulla.jar&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;You will be entered in to the JShell.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hard-way&quot;&gt;Hard way&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;NOTE: The whole build process can take up to 20-30 minutes or more, so brace yourself.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Make sure you have set the JAVA_HOME&lt;&#x2F;li&gt;
&lt;li&gt;You also need Mercurial. If you are on Ubuntu just give &lt;code&gt;sudo apt-get install mercurial&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Then the follow these commands to get kulla-dev branch built
&lt;ul&gt;
&lt;li&gt;hg clone http:&#x2F;&#x2F;hg.openjdk.java.net&#x2F;kulla&#x2F;dev kulla-dev&lt;&#x2F;li&gt;
&lt;li&gt;cd kulla-dev&lt;&#x2F;li&gt;
&lt;li&gt;sh get_sources.sh&lt;&#x2F;li&gt;
&lt;li&gt;bash configure –with-boot-jdk=&#x2F;path&#x2F;to&#x2F;jdk1.9&lt;&#x2F;li&gt;
&lt;li&gt;make clean images&lt;&#x2F;li&gt;
&lt;li&gt;make install  (optional)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;OK, kulla-dev branch is now built, hopefully without any errors. Now lets see how we can build and run the REPL. I&#x27;m extracting these information from official README under Kulla dev branch.&lt;&#x2F;p&gt;
&lt;p&gt;Download JLINE2 from Maven, and set the environment variable JLINE2LIB to point to the downloaded jar file.&lt;&#x2F;p&gt;
&lt;p&gt;Building REPL:-&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;cd langtools&#x2F;repl &lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;bash .&#x2F;scripts&#x2F;compile.sh&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Running:-&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;bash .&#x2F;scripts&#x2F;run.sh&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If everything goes fine you&#x27;ll be entered to the JShell without any issues.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;features&quot;&gt;Features&lt;&#x2F;h3&gt;
&lt;p&gt;I will add a summary of features that you&#x27;ll find useful when using the REPL.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;REPL has networking support. Yes you can work with java.net&lt;&#x2F;li&gt;
&lt;li&gt;Semicolone is optional giving you a flexibility like most of REPL&#x27;s out there&lt;&#x2F;li&gt;
&lt;li&gt;It has some useful help commands that you can use to improve your productivity. &#x2F;help list those commands&lt;&#x2F;li&gt;
&lt;li&gt;Checked exceptions are not valid here. Like in normal Java environment you will not be forced to handle the checked exceptions. REPL will be handling it in the background&lt;&#x2F;li&gt;
&lt;li&gt;Expressions will also work out of the box here. Arithmetic, String manipulations, method calls .etc&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;java.net&#x2F;downloads&#x2F;adoptopenjdk&#x2F;REPL_Tutorial.pdf&quot;&gt;Here&lt;&#x2F;a&gt; I found a good tutorial that might be useful. It has some basic to intermediate exercises that you can follow go get familiar with the JShell&#x2F;REPL&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>JAXB + Maven – Xml to Java</title>
        <published>2013-09-02T00:00:00+00:00</published>
        <updated>2013-09-02T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://noos.blog/posts/jaxb-maven-xml-to-java/"/>
        <id>https://noos.blog/posts/jaxb-maven-xml-to-java/</id>
        
        <content type="html" xml:base="https://noos.blog/posts/jaxb-maven-xml-to-java/">&lt;h3 id=&quot;situation&quot;&gt;Situation&lt;&#x2F;h3&gt;
&lt;p&gt;Assume there&#x27;s a situation where you want to generate Java sources from a xml schema definition (xsd).  And generate it constantly whenever you want it if the xsd&#x27;s got updated.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;&#x2F;h3&gt;
&lt;p&gt;There are quiet a few out tools&#x2F;libs out there but I found this particulate set (Maven and JAXB2) works well for me, just because it&#x27;s pretty straight forward. But you may prefer a different approach.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;in-to-the-action&quot;&gt;In to the action&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s create a very basic maven project (assume you have already set up Maven and Java)&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;mvn archetype:generate -DgroupId={com.jaxb.hello} -DartifactId={HelloJAXB2}
&lt;&#x2F;span&gt;&lt;span&gt; -DarchetypeArtifactId=maven-archetype-quickstart  -DinteractiveMode=false
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once the project is created open the pom.xml file in edit mode and add following two plugins&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;mojo.codehaus.org&#x2F;jaxb2-maven-plugin&#x2F;&quot;&gt;JAXB-2 Maven Plugin&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;plugins&#x2F;maven-source-plugin&#x2F;&quot;&gt;Maven Source Plugin&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;[Since this is a sample project you may have to define the maven &lt;code&gt;&amp;lt;plugins &#x2F;&amp;gt;&lt;&#x2F;code&gt; sections]&lt;&#x2F;p&gt;
&lt;img src=&quot;&#x2F;public&#x2F;images&#x2F;plugins-section.png&quot; alt=&quot;img&quot; class=&quot;inline&quot;&#x2F;&gt;
&lt;p&gt;Carefully notice the sections&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;generatePackage&amp;gt;&lt;&#x2F;code&gt; defines the place where you want to put the generated sources for the xsd&#x27;s&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;schemaIncludes&amp;gt;&lt;&#x2F;code&gt; defines the place where you place your .xsd files.&lt;&#x2F;p&gt;
&lt;p&gt;Now keep all that in mine lets see the project structure&lt;&#x2F;p&gt;
&lt;img src=&quot;&#x2F;public&#x2F;images&#x2F;project-structure.png&quot; alt=&quot;img&quot; class=&quot;inline&quot;&#x2F;&gt;
&lt;p&gt;As you can see I just added a single .xsd to the location helloschema&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;Once all these are in place you just have run the Maven target.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;mvn package&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;img src=&quot;&#x2F;public&#x2F;images&#x2F;final-build.png&quot; alt=&quot;img&quot; class=&quot;inline&quot;&#x2F;&gt;
&lt;p&gt;[Here I have skipped the tests for the convenience]&lt;&#x2F;p&gt;
&lt;p&gt;If everything goes smoothly you&#x27;ll see two .jar files in the target folder&lt;&#x2F;p&gt;
&lt;img src=&quot;&#x2F;public&#x2F;images&#x2F;maven-build.png&quot; alt=&quot;img&quot; class=&quot;inline&quot;&#x2F;&gt;
&lt;p&gt;Sources are bundled in the &lt;code&gt;HelloJAXB2-1.1-SNAPSHOT-sources.jar&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;and you can find it also in &lt;code&gt;generated-sources&lt;&#x2F;code&gt; folder as well&lt;&#x2F;p&gt;
&lt;img src=&quot;&#x2F;public&#x2F;images&#x2F;generated-sources.png&quot; alt=&quot;img&quot; class=&quot;inline&quot;&#x2F;&gt;
</content>
        
    </entry>
</feed>
